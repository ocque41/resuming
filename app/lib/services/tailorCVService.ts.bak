import { logger } from '@/lib/logger';

// Use a runtime check for server-side code
const isServer = typeof window === 'undefined';

/**
 * Interface for the results returned by the tailor-for-job API
 */
interface TailorCVResult {
  tailoredContent: string;
  enhancedProfile: string;
  sectionImprovements: Record<string, string>;
}

/**
 * Interface for the response from the tailor-for-job API
 */
interface TailorCVResponse {
  success: boolean;
  result?: TailorCVResult;
  error?: string;
  errorCode?: string;
  jobId?: string;
  status?: string;
  progress?: number;
  continuePolling?: boolean;
  estimatedTimeRemaining?: number;
  timeoutLevel?: string;
}

/**
 * Interface representing an industry with its specific optimization parameters
 */
interface Industry {
  name: string;
  keywords: string[];
  importantSkills: string[];
  preferredFormats: string[];
  achievementMetrics: string[];
  commonTitles: string[];
}

/**
 * Collection of major industries with their specific optimization parameters
 */
const INDUSTRIES: Industry[] = [
  {
    name: 'Technology',
    keywords: ['software', 'development', 'programming', 'code', 'tech', 'digital', 'IT', 'computer', 'system', 'data', 'analytics', 'cloud', 'infrastructure', 'agile', 'DevOps', 'AI', 'machine learning', 'web', 'mobile', 'app', 'platform', 'API'],
    importantSkills: ['programming languages', 'frameworks', 'databases', 'cloud services', 'version control', 'testing', 'deployment', 'architecture', 'algorithms', 'data structures'],
    preferredFormats: ['skills-first', 'chronological', 'technical project summaries'],
    achievementMetrics: ['code quality', 'system performance', 'optimization %', 'decreased load time', 'increased efficiency', 'reduced bugs', 'improved uptime'],
    commonTitles: ['Software Engineer', 'Developer', 'Architect', 'DevOps Engineer', 'Data Scientist', 'Product Manager', 'Analyst', 'QA Engineer', 'Technical Lead', 'CTO']
  },
  {
    name: 'Finance',
    keywords: ['finance', 'bank', 'accounting', 'financial', 'audit', 'tax', 'revenue', 'budget', 'fiscal', 'investment', 'trading', 'assets', 'wealth', 'capital', 'portfolio', 'risk', 'compliance', 'securities', 'equity', 'profit', 'loss'],
    importantSkills: ['financial analysis', 'accounting', 'Excel', 'financial modeling', 'forecasting', 'budgeting', 'risk assessment', 'regulatory compliance', 'portfolio management'],
    preferredFormats: ['chronological', 'achievement-focused', 'formal'],
    achievementMetrics: ['ROI', 'revenue growth', 'cost reduction', 'portfolio performance', 'efficiency savings', 'audit findings', 'risk mitigation'],
    commonTitles: ['Financial Analyst', 'Accountant', 'Controller', 'Auditor', 'Investment Banker', 'Portfolio Manager', 'Risk Manager', 'CFO', 'Treasurer', 'Tax Specialist']
  },
  {
    name: 'Healthcare',
    keywords: ['healthcare', 'medical', 'clinical', 'patient', 'hospital', 'doctor', 'nurse', 'physician', 'therapy', 'diagnostic', 'treatment', 'pharmaceutical', 'health', 'care', 'wellness', 'disease', 'clinic'],
    importantSkills: ['patient care', 'clinical experience', 'electronic medical records', 'medical terminology', 'treatment planning', 'regulatory compliance', 'medical software'],
    preferredFormats: ['chronological', 'credential-focused', 'licensing-prominent'],
    achievementMetrics: ['patient outcomes', 'compliance rates', 'treatment efficacy', 'patient satisfaction', 'reduced readmissions', 'care quality metrics'],
    commonTitles: ['Physician', 'Nurse', 'Medical Director', 'Clinical Manager', 'Healthcare Administrator', 'Patient Care Coordinator', 'Medical Technician', 'Therapist']
  },
  {
    name: 'Marketing',
    keywords: ['marketing', 'brand', 'campaign', 'digital', 'social media', 'content', 'SEO', 'advertising', 'creative', 'strategy', 'audience', 'market', 'consumer', 'promotion', 'engagement', 'conversion', 'analytics', 'traffic'],
    importantSkills: ['content creation', 'social media management', 'SEO', 'analytics tools', 'campaign management', 'audience targeting', 'creative direction', 'CRM'],
    preferredFormats: ['achievement-focused', 'portfolio-linked', 'creative'],
    achievementMetrics: ['conversion rates', 'engagement metrics', 'traffic growth', 'ROI', 'market share', 'brand awareness', 'customer acquisition cost'],
    commonTitles: ['Marketing Manager', 'Digital Marketer', 'Content Strategist', 'Brand Manager', 'Social Media Specialist', 'SEO Expert', 'Marketing Director', 'Growth Hacker']
  },
  {
    name: 'Sales',
    keywords: ['sales', 'business development', 'account', 'revenue', 'client', 'customer', 'pipeline', 'target', 'quota', 'deal', 'lead', 'prospect', 'closing', 'negotiation', 'relationship', 'CRM', 'B2B', 'B2C'],
    importantSkills: ['negotiation', 'relationship building', 'CRM software', 'pipeline management', 'closing techniques', 'prospecting', 'account management', 'sales presentations'],
    preferredFormats: ['results-first', 'achievement-focused', 'metrics-driven'],
    achievementMetrics: ['revenue generated', 'quota attainment', 'deal size', 'sales cycle reduction', 'client retention', 'upselling', 'conversion rate'],
    commonTitles: ['Sales Representative', 'Account Executive', 'Business Development Manager', 'Sales Manager', 'Account Manager', 'Sales Director', 'VP of Sales', 'Customer Success Manager']
  },
  {
    name: 'Engineering',
    keywords: ['engineering', 'mechanical', 'electrical', 'civil', 'chemical', 'design', 'construction', 'manufacturing', 'industrial', 'product', 'technical', 'CAD', 'simulation', 'prototype', 'production', 'quality', 'standards'],
    importantSkills: ['CAD software', 'design techniques', 'engineering analysis', 'quality control', 'project management', 'technical specifications', 'regulatory compliance', 'testing methodologies'],
    preferredFormats: ['chronological', 'project-based', 'technical skills-prominent'],
    achievementMetrics: ['design improvements', 'efficiency gains', 'cost reduction', 'quality metrics', 'production yield', 'compliance rates', 'innovation metrics'],
    commonTitles: ['Mechanical Engineer', 'Electrical Engineer', 'Civil Engineer', 'Process Engineer', 'Product Engineer', 'Design Engineer', 'Project Engineer', 'Quality Engineer']
  },
  {
    name: 'Education',
    keywords: ['education', 'teaching', 'school', 'academic', 'student', 'learning', 'curriculum', 'classroom', 'instruction', 'educational', 'teacher', 'professor', 'faculty', 'pedagogy', 'assessment', 'training'],
    importantSkills: ['curriculum development', 'classroom management', 'student assessment', 'educational technology', 'instructional design', 'differentiated instruction', 'lesson planning'],
    preferredFormats: ['credential-first', 'chronological', 'teaching philosophy inclusion'],
    achievementMetrics: ['student performance improvement', 'program development', 'assessment outcomes', 'student engagement', 'graduation rates', 'curriculum adoption'],
    commonTitles: ['Teacher', 'Professor', 'Instructor', 'Principal', 'Academic Advisor', 'Education Coordinator', 'Dean', 'Department Chair', 'Curriculum Developer']
  },
  {
    name: 'Legal',
    keywords: ['legal', 'law', 'attorney', 'counsel', 'litigation', 'contract', 'compliance', 'regulatory', 'statute', 'court', 'judicial', 'legislation', 'policy', 'rights', 'investigation', 'claims', 'dispute'],
    importantSkills: ['legal research', 'case management', 'contract drafting', 'negotiation', 'client counseling', 'litigation', 'regulatory compliance', 'legal writing'],
    preferredFormats: ['credential-focused', 'chronological', 'formal'],
    achievementMetrics: ['case outcomes', 'settlement amounts', 'compliance improvements', 'risk mitigation', 'contract efficiencies', 'successful negotiations'],
    commonTitles: ['Attorney', 'Lawyer', 'Legal Counsel', 'Paralegal', 'Compliance Officer', 'Legal Assistant', 'General Counsel', 'Contract Manager', 'Litigation Specialist']
  }
];

/**
 * Identify industry from job description
 * 
 * @param jobDescription - The job description text
 * @returns The identified industry or undefined if no clear match
 */
function identifyIndustry(jobDescription: string): Industry | undefined {
  const jobText = jobDescription.toLowerCase();
  
  // Calculate a match score for each industry
  const industryScores = INDUSTRIES.map(industry => {
    let score = 0;
    
    // Check for industry keywords in the job description
    industry.keywords.forEach(keyword => {
      const regex = new RegExp(`\\b${keyword.toLowerCase()}\\b`, 'g');
      const matches = jobText.match(regex);
      if (matches) {
        score += matches.length;
      }
    });
    
    // Check for common job titles
    industry.commonTitles.forEach(title => {
      if (jobText.includes(title.toLowerCase())) {
        score += 3; // Higher weight for title matches
      }
    });
    
    return { industry, score };
  });
  
  // Sort by score descending
  const sortedIndustries = industryScores.sort((a, b) => b.score - a.score);
  
  // Return the industry with the highest score if it's significant (threshold of 3)
  return sortedIndustries[0].score >= 3 ? sortedIndustries[0].industry : undefined;
}

/**
 * Get industry-specific optimization guidance
 * 
 * @param jobDescription - The job description text
 * @returns Object containing industry-specific optimization guidance
 */
export function getIndustryOptimizationGuidance(jobDescription: string): {
  industry: string;
  keySkills: string[];
  suggestedMetrics: string[];
  formatGuidance: string;
} {
  // Identify the industry
  const industry = identifyIndustry(jobDescription);
  
  if (!industry) {
    // Default generic guidance if no specific industry is detected
    return {
      industry: 'General',
      keySkills: ['communication', 'teamwork', 'project management', 'problem-solving', 'organization'],
      suggestedMetrics: ['efficiency improvements', 'cost savings', 'project completion', 'team coordination'],
      formatGuidance: 'Use a clean, chronological format with clear section headings'
    };
  }
  
  // Ensure all required arrays exist with fallbacks
  const importantSkills = Array.isArray(industry.importantSkills) && industry.importantSkills.length > 0 
    ? industry.importantSkills 
    : ['communication', 'teamwork', 'industry-specific knowledge'];
    
  const achievementMetrics = Array.isArray(industry.achievementMetrics) && industry.achievementMetrics.length > 0
    ? industry.achievementMetrics
    : ['efficiency improvements', 'cost savings', 'project completion'];
    
  const preferredFormats = Array.isArray(industry.preferredFormats) && industry.preferredFormats.length > 0
    ? industry.preferredFormats
    : ['chronological', 'achievement-focused'];
  
  // Return industry-specific guidance with validated arrays
  return {
    industry: industry.name,
    keySkills: importantSkills,
    suggestedMetrics: achievementMetrics,
    formatGuidance: `Consider using ${preferredFormats.join(' or ')} format for ${industry.name} roles`
  };
}

/**
 * Maximum time to wait for tailoring job to complete (in milliseconds)
 */
const MAX_POLLING_TIME = 180000; // 3 minutes (reduced from 5 minutes)

/**
 * Polling interval for checking job status (in milliseconds)
 */
const POLLING_INTERVAL = 3000;  // 3 seconds (reduced from 4 seconds)

/**
 * Maximum number of retries for API calls
 */
const MAX_RETRIES = 4;

/**
 * Retry backoff factor (milliseconds)
 */
const RETRY_BACKOFF_FACTOR = 1.5;

/**
 * Timeout thresholds for different levels
 */
const TIMEOUT_THRESHOLDS = {
  SHORT: 30000,   // 30 seconds (reduced from 45 seconds)
  MEDIUM: 90000,  // 90 seconds (reduced from 120 seconds)
  LONG: 150000,   // 150 seconds (reduced from 240 seconds)
};

/**
 * Retry an async function with exponential backoff
 */
async function retryWithBackoff<T>(
  fn: () => Promise<T>, 
  maxRetries: number = MAX_RETRIES,
  backoff: number = RETRY_BACKOFF_FACTOR,
  retryableErrors: string[] = []
): Promise<T> {
  let lastError: any;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      const errorMessage = error instanceof Error ? error.message : String(error);
      
      logger.warn(`Attempt ${attempt + 1}/${maxRetries} failed:`, errorMessage);
      
      // Check if this is a retryable error
      const shouldRetry = retryableErrors.length === 0 || 
                          retryableErrors.some(errType => errorMessage.includes(errType));
      
      if (!shouldRetry) {
        logger.error(`Error type not retryable: ${errorMessage}`);
        throw error;
      }
      
      // Exponential backoff with jitter
      const delay = backoff * Math.pow(2, attempt) * (0.9 + Math.random() * 0.2);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError;
}

/**
 * Poll for job status with a timeout and progress updates
 * 
 * @param jobId The job ID to poll for status
 * @param progressCallback Optional callback to report progress during polling
 * @param options Additional options for polling behavior
 * @returns Promise resolving to the tailoring result
 */
export async function pollJobStatus(
  jobId: string, 
  progressCallback?: (progress: number) => Promise<void>,
  options: {
    maxPollingTime?: number;
    pollingInterval?: number;
    retryOnTimeout?: boolean;
    abortSignal?: AbortSignal;
    acceptPartialResults?: boolean; // Added option to accept partial results
  } = {}
): Promise<TailorCVResult> {
  logger.info(`Polling job status for job ${jobId}`);
  
  // Setup options with defaults
  const maxPollingTime = options.maxPollingTime || MAX_POLLING_TIME;
  const pollingInterval = options.pollingInterval || POLLING_INTERVAL;
  const abortSignal = options.abortSignal;
  const acceptPartialResults = options.acceptPartialResults !== undefined ? options.acceptPartialResults : true;
  
  // Track last progress update to reduce log noise
  let lastProgressUpdate = 0;
  let consecutiveErrors = 0;
  let lastTimeoutLevel: string | null = null;
  
  // Track total time spent polling
  const startTime = Date.now();
  
  // Response tracker for detecting patterns
  const responseHistory: Array<{time: number, progress: number, status: string}> = [];
  
  // Keep track of the best partial result we've seen
  let bestPartialResult: TailorCVResult | null = null;
  let bestPartialProgress = 0;
  
  while (Date.now() - startTime < maxPollingTime) {
    // Check for abort signal
    if (abortSignal?.aborted) {
      logger.warn(`Polling aborted for job ${jobId}`);
      
      // If we have a partial result and we're accepting those, return it
      if (acceptPartialResults && bestPartialResult && bestPartialProgress >= 60) {
        logger.info(`Returning partial result with ${bestPartialProgress}% completion after polling was aborted`);
        return bestPartialResult;
      }
      
      throw new Error('Polling was aborted');
    }
    
    try {
      // Add retries for network issues
      const response = await retryWithBackoff(
        async () => await fetch(`/api/cv/tailor-for-job/status?jobId=${jobId}`),
        MAX_RETRIES,
        RETRY_BACKOFF_FACTOR,
        ['network', 'timeout', 'failed to fetch']
      );
      
      if (!response.ok) {
        logger.error(`Error polling job status: ${response.status} ${response.statusText}`);
        
        // If server error, wait a bit before retrying
        if (response.status >= 500) {
          consecutiveErrors++;
          // If we get multiple errors in a row, wait longer
          const errorBackoff = Math.min(pollingInterval * Math.pow(2, consecutiveErrors - 1), 10000);
          await new Promise(resolve => setTimeout(resolve, errorBackoff));
          continue;
        }
        
        // For 404 (job not found), this is a terminal error
        if (response.status === 404) {
          throw new Error(`Job ${jobId} not found`);
        }
        
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }
      
      // Reset error counter on successful response
      consecutiveErrors = 0;
      
      const data = await response.json() as TailorCVResponse;
      
      // Add response to history for pattern detection
      if (data.progress !== undefined && data.status) {
        responseHistory.push({
          time: Date.now() - startTime,
          progress: data.progress,
          status: data.status
        });
      }
      
      // Store partial result if it's better than what we have
      if (acceptPartialResults && data.result && data.progress && data.progress > bestPartialProgress && data.progress >= 50) {
        bestPartialResult = data.result;
        bestPartialProgress = data.progress;
        logger.info(`Stored partial result with ${data.progress}% completion`);
      }
      
      // Handle timeout indication from server with different severity levels
      if (data.status === 'timeout') {
        lastTimeoutLevel = data.timeoutLevel || 'medium';
        
        logger.warn(`Job ${jobId} timeout level: ${lastTimeoutLevel}`);
        
        // For short timeouts, continue polling normally
        if (lastTimeoutLevel === 'short') {
          // Just log and continue
          logger.info(`Short timeout for job ${jobId}, continuing polling`);
        }
        
        // For medium timeouts, adjust polling interval
        if (lastTimeoutLevel === 'medium') {
          logger.warn(`Medium timeout for job ${jobId}, adjusting polling interval`);
          // Increase polling interval to reduce load
          await new Promise(resolve => setTimeout(resolve, pollingInterval * 1.5));
          
          // Continue if server says to
          if (data.continuePolling === false) {
            logger.warn(`Server requested to stop polling for job ${jobId}`);
            
            // Return partial result if we have one and are accepting those
            if (acceptPartialResults && bestPartialResult && bestPartialProgress >= 60) {
              logger.info(`Returning partial result with ${bestPartialProgress}% completion after server timeout`);
              
              // Final progress update
              if (progressCallback) {
                await progressCallback(100);
              }
              
              return bestPartialResult;
            }
            
            throw new Error(`Job processing timed out after ${Math.round((Date.now() - startTime) / 1000)} seconds. The job may complete in the background.`);
          }
          continue;
        }
        
        // For long timeouts, decide whether to continue based on server instruction and options
        if (lastTimeoutLevel === 'long') {
          logger.error(`Long timeout for job ${jobId}`);
          
          // Return partial result if we have one and are accepting those
          if (acceptPartialResults && bestPartialResult && bestPartialProgress >= 60) {
            logger.info(`Returning partial result with ${bestPartialProgress}% completion after long timeout`);
            
            // Final progress update
            if (progressCallback) {
              await progressCallback(100);
            }
            
            return bestPartialResult;
          }
          
          if (data.continuePolling === false || !options.retryOnTimeout) {
            logger.warn(`Giving up on job ${jobId} due to long timeout`);
            throw new Error(`Job processing timed out after ${Math.round((Date.now() - startTime) / 1000)} seconds. The job may still complete in the background.`);
          } else {
            logger.info(`Continuing to poll for job ${jobId} despite long timeout`);
            // Increase polling interval significantly
            await new Promise(resolve => setTimeout(resolve, pollingInterval * 2));
            continue;
          }
        }
      }
      
      // If job completed successfully, return the result
      if (data.success && data.status === 'completed' && data.result) {
        logger.info(`Job ${jobId} completed successfully after ${Math.round((Date.now() - startTime) / 1000)} seconds`);
        
        // Final progress update
        if (progressCallback && data.progress && data.progress < 100) {
          await progressCallback(100);
        }
        
        return data.result;
      }
      
      // If job failed, throw an error with details
      if (data.status === 'error' || !data.success) {
        const errorMessage = data.error || 'Job processing failed';
        const errorCode = data.errorCode || 'UNKNOWN_ERROR';
        
        logger.error(`Job ${jobId} failed with error code ${errorCode}: ${errorMessage}`);
        
        // Return partial result if we have one and are accepting those
        if (acceptPartialResults && bestPartialResult && bestPartialProgress >= 60) {
          logger.info(`Returning partial result with ${bestPartialProgress}% completion after job error`);
          
          // Final progress update 
          if (progressCallback) {
            await progressCallback(90); // Not 100% since there was an error
          }
          
          return bestPartialResult;
        }
        
        const error = new Error(errorMessage);
        (error as any).code = errorCode;
        (error as any).jobId = jobId;
        
        throw error;
      }
      
      // Report progress if it has changed significantly
      if (progressCallback && data.progress !== undefined && Math.abs(data.progress - lastProgressUpdate) >= 5) {
        await progressCallback(data.progress);
        lastProgressUpdate = data.progress;
        
        // Log progress
        logger.info(`Job ${jobId} progress: ${data.progress}%`);
        
        // Show estimated time remaining if available
        if (data.estimatedTimeRemaining) {
          logger.info(`Estimated time remaining for job ${jobId}: ${data.estimatedTimeRemaining} seconds`);
        }
      }
      
      // Check if we should return early with a good-enough partial result
      // If we're at 85% or more after 120 seconds, we can probably return that result
      const timeElapsed = Date.now() - startTime;
      if (acceptPartialResults && bestPartialResult && bestPartialProgress >= 85 && timeElapsed > 120000) {
        logger.info(`Returning high-quality partial result (${bestPartialProgress}%) early to avoid timeout`);
        
        // Final progress update
        if (progressCallback) {
          await progressCallback(100);
        }
        
        return bestPartialResult;
      }
      
      // Wait before next poll with small jitter to avoid thundering herd
      const jitter = Math.random() * 500;
      await new Promise(resolve => setTimeout(resolve, pollingInterval + jitter));
    } catch (error) {
      consecutiveErrors++;
      const errorMessage = error instanceof Error ? error.message : String(error);
      
      logger.error(`Error polling job status for ${jobId} (attempt ${consecutiveErrors}):`, errorMessage);
      
      // If we get too many consecutive errors, check if we can return a partial result
      if (consecutiveErrors >= 5) {
        if (acceptPartialResults && bestPartialResult && bestPartialProgress >= 60) {
          logger.info(`Returning partial result with ${bestPartialProgress}% completion after consecutive errors`);
          
          // Final progress update
          if (progressCallback) {
            await progressCallback(90); // Not 100% since there was an error
          }
          
          return bestPartialResult;
        }
        
        throw new Error(`Too many consecutive errors while polling job status: ${errorMessage}`);
      }
      
      // If the error is a network error, retry with longer interval
      const isNetworkError = 
        errorMessage.includes('network') || 
        errorMessage.includes('fetch') || 
        errorMessage.includes('timeout');
      
      // Wait with increasing backoff before retrying
      const errorBackoff = isNetworkError
        ? Math.min(pollingInterval * Math.pow(1.5, consecutiveErrors - 1), 15000)
        : Math.min(pollingInterval * Math.pow(2, consecutiveErrors - 1), 10000);
        
      await new Promise(resolve => setTimeout(resolve, errorBackoff));
    }
  }
  
  // If we reached here, we timed out but might have a partial result
  logger.warn(`Polling timeout for job ${jobId} after ${maxPollingTime / 1000} seconds`);
  
  // Check if we can return a partial result
  if (acceptPartialResults && bestPartialResult && bestPartialProgress >= 60) {
    logger.info(`Returning partial result with ${bestPartialProgress}% completion after maximum polling time`);
    
    // Final progress update
    if (progressCallback) {
      await progressCallback(95); // Not 100% since we timed out
    }
    
    return bestPartialResult;
  }
  
  // Create a detailed timeout error
  const timeoutError = new Error(`Job processing timed out after ${maxPollingTime / 1000} seconds. The job is still processing in the background and may complete later.`);
  (timeoutError as any).code = 'POLLING_TIMEOUT';
  (timeoutError as any).jobId = jobId;
  (timeoutError as any).timeSpent = Math.round((Date.now() - startTime) / 1000);
  (timeoutError as any).lastProgress = lastProgressUpdate;
  (timeoutError as any).lastTimeoutLevel = lastTimeoutLevel;
  
  throw timeoutError;
}

/**
 * Service function to call the tailor-for-job API
 * 
 * @param cvText - The original CV text to be tailored
 * @param params - Parameters for tailoring including jobDescription, jobTitle, etc.
 * @param progressCallback - Optional callback to report progress during processing
 * @returns A promise that resolves to the tailored CV content and enhancements
 */
export async function tailorCVForJob(
  cvText: string,
  params: {
    jobDescription?: string;
    jobTitle?: string;
    industry?: string;
    keySkills?: string[];
    cvId: string;
    priority?: string;
  },
  progressCallback?: (progress: number) => Promise<void>
): Promise<{
  tailoredContent: string;
  enhancedProfile: string;
  sectionImprovements: Record<string, string>;
  success: boolean;
  error?: string;
  errorCode?: string;
  jobId?: string;
  industryInsights?: {
    industry: string;
    keySkills: string[];
    suggestedMetrics: string[];
    formatGuidance: string;
  };
}> {
  logger.info('Starting CV tailoring process');
  
  try {
    // Extract parameters
    const { jobDescription, jobTitle, cvId, priority } = params;
    
    // Get industry-specific optimization guidance if we have a job description
    const industryInsights = jobDescription ? 
      getIndustryOptimizationGuidance(jobDescription) : 
      {
        industry: 'General',
        keySkills: ['communication', 'teamwork', 'problem-solving'],
        suggestedMetrics: ['efficiency improvements', 'project completion'],
        formatGuidance: 'Use a clean, chronological format with clear section headings'
      };
    
    // Default empty result
    const defaultResult = {
      tailoredContent: '',
      enhancedProfile: '',
      sectionImprovements: {},
      success: false,
      error: 'Failed to tailor CV',
      industryInsights
    };
    
    // Check required parameters
    if (!cvText) {
      logger.error('Missing cvText parameter for tailorCVForJob');
      return {
        ...defaultResult,
        error: 'CV text is required'
      };
    }
    
    if (!jobDescription) {
      logger.error('Missing jobDescription parameter for tailorCVForJob');
      return {
        ...defaultResult,
        error: 'Job description is required'
      };
    }
    
    if (!cvId) {
      logger.error('Missing cvId parameter for tailorCVForJob');
      return {
        ...defaultResult,
        error: 'CV ID is required'
      };
    }
    
    // Report initial progress
    if (progressCallback) {
      await progressCallback(5);
    }
    
    try {
      // Use the Mistral service for direct processing when server-side
      if (isServer) {
        logger.info('Using direct Mistral processing for tailoring');
        
        try {
          // Import the Mistral service
          const { tailorCVForSpecificJob } = await import('@/app/lib/services/mistral.service');
          
          // Update progress
          if (progressCallback) {
            await progressCallback(25);
          }
          
          // Process with the Mistral AI service
          const result = await tailorCVForSpecificJob(
            cvText, 
            jobTitle || 'Not specified', 
            jobDescription || '', 
            { detailed: true }
          );
          
          // Update progress
          if (progressCallback) {
            await progressCallback(90);
          }
          
          // Return successful result with industry insights
          return {
            tailoredContent: result.optimizedText || cvText,
            enhancedProfile: result.analysis ? result.analysis.split('\n').slice(0, 3).join('\n') : '',
            sectionImprovements: { overall: result.analysis || 'CV tailored for the job position' },
            success: true,
            industryInsights
          };
        } catch (error) {
          // Handle errors from the Mistral service
          logger.error('Error in direct Mistral processing:', 
            error instanceof Error ? error.message : String(error));
          throw error;
        }
      }
      
      // If client-side, use the API endpoint
      logger.info('Starting tailoring job via API');
      
      // Determine if this is a high-priority job
      const isPriorityJob = priority === 'high';
      
      // Start the tailoring job
      const response = await fetch('/api/cv/tailor-for-job', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          cvText,
          jobDescription,
          jobTitle,
          cvId,
          priority: isPriorityJob ? 'high' : 'normal',
          // Include industry insights for better tailoring
          industryInsights: {
            industry: industryInsights.industry || 'General',
            keySkills: Array.isArray(industryInsights.keySkills) ? industryInsights.keySkills : [],
            suggestedMetrics: Array.isArray(industryInsights.suggestedMetrics) ? industryInsights.suggestedMetrics : [],
            formatGuidance: industryInsights.formatGuidance || ''
          }
        }),
      });
      
      // Handle non-OK responses
      if (!response.ok) {
        const errorText = await response.text();
        logger.error(`Error starting tailoring job: ${response.status} - ${errorText}`);
        return {
          ...defaultResult,
          error: `API error: ${response.status} ${response.statusText}`
        };
      }
      
      // Parse response
      const data = await response.json() as TailorCVResponse;
      
      // Handle API-level failures
      if (!data.success || !data.jobId) {
        logger.error(`API reported failure: ${data.error || 'Unknown error'}`);
        return {
          ...defaultResult,
          error: data.error || 'Unknown error from API',
          errorCode: data.errorCode
        };
      }
      
      // Poll for job completion
      try {
        // Update progress
        if (progressCallback) {
          await progressCallback(15);
        }
        
        // Set up abort controller for timeout
        const abortController = new AbortController();
        
        // Set up polling options based on priority
        const pollingOptions = {
          maxPollingTime: isPriorityJob ? MAX_POLLING_TIME + 120000 : MAX_POLLING_TIME, // Add 2 minutes for high priority
          pollingInterval: isPriorityJob ? POLLING_INTERVAL - 1000 : POLLING_INTERVAL, // Poll faster for high priority
          retryOnTimeout: isPriorityJob, // Auto-retry on timeout for high priority
          abortSignal: abortController.signal
        };
        
        // Poll for job status with appropriate options
        const result = await pollJobStatus(data.jobId, progressCallback, pollingOptions);
        
        // Return the successful result with industry insights
        return {
          tailoredContent: result.tailoredContent || cvText,
          enhancedProfile: result.enhancedProfile || '',
          sectionImprovements: result.sectionImprovements || {},
          success: true,
          jobId: data.jobId,
          industryInsights
        };
      } catch (pollError) {
        const errorMessage = pollError instanceof Error ? pollError.message : String(pollError);
        const errorCode = (pollError as any)?.code || 'UNKNOWN_ERROR';
        
        logger.error(`Error polling for job completion (${errorCode}): ${errorMessage}`);
        
        return {
          ...defaultResult,
          error: errorMessage,
          errorCode: errorCode,
          jobId: data.jobId, // Include jobId so client can retry if needed
        };
      }
    } catch (processingError) {
      const errorMessage = processingError instanceof Error ? processingError.message : String(processingError);
      logger.error(`Error in CV processing: ${errorMessage}`);
      
      return {
        ...defaultResult,
        error: errorMessage
      };
    }
  } catch (error) {
    // Catch any unexpected errors
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`Error in tailorCVForJob: ${errorMessage}`);
    
    return {
      tailoredContent: '',
      enhancedProfile: '',
      sectionImprovements: {},
      success: false,
      error: errorMessage,
      industryInsights: params.jobDescription ? getIndustryOptimizationGuidance(params.jobDescription) : undefined
    };
  }
} 