import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, BorderStyle, TabStopPosition, TabStopType, UnderlineType, ShadingType, WidthType, Table, TableRow, TableCell, ImageRun } from "docx";

interface DocxGenerationOptions {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string[];
  description?: string;
  atsScore?: number;
  improvedAtsScore?: number;
  improvements?: string[];
  experienceEntries?: Array<{
    jobTitle: string;
    company: string;
    dateRange: string;
    location?: string;
    responsibilities: string[];
  }>;
  industry?: string;
  template?: string;
}

/**
 * Generates a DOCX file from optimized CV text
 * @param cvText The optimized CV text to convert to DOCX
 * @param options Additional options for the DOCX document
 * @returns A Buffer containing the generated DOCX file
 */
export async function generateDocx(cvText: string, options: DocxGenerationOptions = {}): Promise<Buffer> {
  if (!cvText) {
    throw new Error('CV text is required');
  }

  try {
    // Log what we're processing
    console.log(`Generating DOCX document from ${cvText.length} characters of text`);
    
    // Validate options and use safe defaults for everything
    const safeOptions = {
      title: options.title?.substring(0, 100) || "Optimized_CV",
      author: options.author?.substring(0, 100) || "CV Optimizer",
      description: options.description?.substring(0, 255) || "Optimized CV generated by CV Optimizer",
      atsScore: typeof options.atsScore === 'number' ? Math.min(Math.max(options.atsScore, 0), 100) : 0,
      improvedAtsScore: typeof options.improvedAtsScore === 'number' ? Math.min(Math.max(options.improvedAtsScore, 0), 100) : 0,
      industry: options.industry?.substring(0, 100) || 'General',
      experienceEntries: Array.isArray(options.experienceEntries) ? 
        options.experienceEntries
          .filter(entry => typeof entry === 'object' && entry !== null) // Ensure valid entries
          .map(entry => ({
            jobTitle: typeof entry.jobTitle === 'string' ? entry.jobTitle.substring(0, 200) : '',
            company: typeof entry.company === 'string' ? entry.company.substring(0, 200) : '',
            dateRange: typeof entry.dateRange === 'string' ? entry.dateRange.substring(0, 100) : '',
            location: typeof entry.location === 'string' ? entry.location.substring(0, 100) : '',
            responsibilities: Array.isArray(entry.responsibilities) ? 
              entry.responsibilities
                .filter(r => typeof r === 'string')
                .map(r => r.substring(0, 500)) : [] // Limit each responsibility to 500 chars
          }))
          .filter(entry => entry.jobTitle || entry.company) : [], // At least one of these must be present
      improvements: Array.isArray(options.improvements) ? 
        options.improvements
          .filter(imp => typeof imp === 'string')
          .map(imp => imp.substring(0, 300)) : [], // Limit each improvement to 300 chars
      template: typeof options.template === 'string' && 
                ['professional', 'modern', 'minimal', 'creative'].includes(options.template) ? 
                options.template : 'professional'
    };
    
    // Get template settings
    const template = getTemplateSettings(safeOptions.template);
    
    // Parse the optimized text to identify sections
    const sections = parseOptimizedText(cvText.substring(0, 20000)); // Limit to 20k chars
    
    // Validate sections - make sure all section values are strings or arrays of strings
    Object.keys(sections).forEach(key => {
      const sectionKey = key as keyof typeof sections;
      
      if (sectionKey === 'achievements' || sectionKey === 'goals') {
        // These should be arrays of strings
        if (!Array.isArray(sections[sectionKey])) {
          sections[sectionKey] = [];
        } else {
          // Filter to ensure each item is a string
          sections[sectionKey] = (sections[sectionKey] as any[])
            .filter(item => typeof item === 'string')
            .map(item => (item as string).substring(0, 1000)); // Limit each item to 1000 chars
        }
      } else {
        // These should be strings
        if (typeof sections[sectionKey] !== 'string') {
          sections[sectionKey] = '';
        } else {
          // Limit string length based on section type
          const maxLength = 
            sectionKey === 'header' ? 500 :
            sectionKey === 'profile' ? 2000 :
            sectionKey === 'experience' ? 5000 :
            sectionKey === 'skills' ? 2000 :
            sectionKey === 'languages' ? 1000 :
            sectionKey === 'education' ? 2000 : 1000;
            
          sections[sectionKey] = (sections[sectionKey] as string).substring(0, maxLength);
        }
      }
    });
    
    // Sanitize text
    if (typeof sections.header === 'string') {
      sections.header = sections.header.substring(0, 500); // Limit header length
    }
    
    if (typeof sections.profile === 'string') {
      sections.profile = sections.profile.substring(0, 2000); // Limit profile length
    }
    
    if (typeof sections.experience === 'string') {
      sections.experience = sections.experience.substring(0, 5000); // Limit experience length
    }
    
    if (typeof sections.skills === 'string') {
      sections.skills = sections.skills.substring(0, 2000); // Limit skills length
    }
    
    if (typeof sections.languages === 'string') {
      sections.languages = sections.languages.substring(0, 1000); // Limit languages length
    }
    
    if (typeof sections.education === 'string') {
      sections.education = sections.education.substring(0, 2000); // Limit education length
    }
    
    console.log("Creating document with valid sections and template:", template.name);
    
    // Create the document with minimal styling - focus on reliability first
    const doc = new Document({
      creator: safeOptions.author,
      title: safeOptions.title,
      description: safeOptions.description,
      styles: {
        paragraphStyles: [
          {
            id: "Heading1",
            name: "Heading 1",
            basedOn: "Normal",
            next: "Normal",
            quickFormat: true,
            run: {
              size: 32,
              bold: true,
              color: template.headerColor,
              font: template.headingFont,
            },
            paragraph: {
              spacing: {
                after: 120,
              },
            },
          },
          {
            id: "Heading2",
            name: "Heading 2", 
            basedOn: "Normal",
            next: "Normal",
            quickFormat: true,
            run: {
              size: 28,
              bold: true,
              color: template.accentColor,
              font: template.headingFont,
            },
            paragraph: {
              spacing: {
                before: 240,
                after: 120,
              },
              border: {
                bottom: {
                  color: "#EEEEEE",
                  space: 1,
                  style: BorderStyle.SINGLE,
                  size: 8,
                },
              },
            },
          }
        ],
      },
      sections: [{
        properties: {
          page: {
            margin: {
              top: 1000,
              right: 1000,
              bottom: 1000,
              left: 1000,
            },
          },
        },
        children: createEnhancedDocumentContent(sections, safeOptions, template),
      }],
    });
    
    console.log("Document object created, generating buffer...");
    
    // Generate the document as a buffer without excessive options
    const buffer = await Packer.toBuffer(doc);
    
    // Validate the buffer
    if (!buffer || buffer.length === 0) {
      throw new Error("Generated an empty document buffer");
    }
    
    // Additional validation - check if buffer starts with PK (ZIP file signature)
    if (buffer.length < 4 || buffer[0] !== 0x50 || buffer[1] !== 0x4B) {
      // Log buffer details for debugging
      console.error(`Invalid buffer generated. First bytes: ${buffer.slice(0, 10).toString('hex')}`);
      throw new Error("Generated buffer is not a valid DOCX/ZIP file");
    }
    
    // Check if buffer size is suspiciously small (likely corrupt)
    if (buffer.length < 2000) {
      console.warn(`Document buffer is suspiciously small (${buffer.length} bytes), may be corrupt`);
      
      // Try to create a minimal document as a fallback
      try {
        const minimalDoc = new Document({
          sections: [{
            properties: {},
            children: [
              new Paragraph({
                text: "Optimized CV Content",
                heading: HeadingLevel.HEADING_1
              }),
              new Paragraph({
                text: cvText.substring(0, 5000) // Include just the text content
              })
            ]
          }]
        });
        
        const fallbackBuffer = await Packer.toBuffer(minimalDoc);
        if (fallbackBuffer && fallbackBuffer.length > 2000) {
          console.log(`Successfully created fallback document (${fallbackBuffer.length} bytes)`);
          return fallbackBuffer;
        }
      } catch (fallbackError) {
        console.error("Failed to create fallback document:", fallbackError);
        // Continue with original buffer
      }
    }
    
    console.log(`Successfully generated DOCX buffer of ${buffer.length} bytes`);
    return buffer;
  } catch (error) {
    console.error("Error generating DOCX:", error);
    // Re-throw with more context to help debugging
    throw new Error(`Failed to generate DOCX document: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Creates enhanced document content with better styling while maintaining robustness
 */
function createEnhancedDocumentContent(sections: any, options: any, template: any): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  // Add header (name and contact info)
  if (sections.header) {
    const headerLines = sections.header.split('\n').filter((line: string) => line.trim());
        
        if (headerLines.length > 0) {
          // First line is the name - make it prominent
          paragraphs.push(
            new Paragraph({
              text: headerLines[0],
              heading: HeadingLevel.HEADING_1,
              alignment: AlignmentType.CENTER,
              spacing: {
                after: 120,
              },
              border: {
                bottom: {
              color: template.accentColor,
                  space: 1,
                  style: BorderStyle.SINGLE,
              size: 4,
                },
          }
            })
          );
          
          // Contact info on one line
          if (headerLines.length > 1) {
            const contactInfo = headerLines.slice(1).join(' | ');
            paragraphs.push(
              new Paragraph({
                alignment: AlignmentType.CENTER,
                children: [
                  new TextRun({
                    text: contactInfo,
                    size: 20,
                    color: "666666",
                font: template.bodyFont,
                  }),
                ],
                spacing: {
                  after: 240,
                },
              })
            );
          }
    }
  }
  
  // Process each section with enhanced formatting
  const sectionOrder = ["profile", "experience", "achievements", "goals", "skills", "languages", "education"];
  
  for (const sectionKey of sectionOrder) {
    // Skip empty sections
    if (!sections[sectionKey] || 
        (typeof sections[sectionKey] === 'string' && !sections[sectionKey].trim()) ||
        (Array.isArray(sections[sectionKey]) && sections[sectionKey].length === 0)) {
      continue;
    }
    
    // Add section heading with template styling
    const title = getSectionTitle(sectionKey);
    paragraphs.push(
      new Paragraph({
        text: title,
        heading: HeadingLevel.HEADING_2,
        spacing: {
          before: 240,
          after: 120,
        },
      })
    );
    
    // Handle content based on section type
    if (sectionKey === 'achievements' || sectionKey === 'goals') {
      // These are arrays of bullet points
      const items = sections[sectionKey] as string[];
      
      // Adding context before bullet points for these sections
      if (sectionKey === 'achievements' && items.length > 0) {
        paragraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: "Key professional accomplishments with measurable outcomes:",
                italics: true,
                size: 22,
                font: template.bodyFont,
              }),
            ],
            spacing: {
              after: 60,
            },
          })
        );
      } else if (sectionKey === 'goals' && items.length > 0) {
        paragraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: "Professional objectives and career aspirations:",
                italics: true,
                size: 22,
                font: template.bodyFont,
              }),
            ],
            spacing: {
              after: 60,
            },
          })
        );
      }
      
      items.forEach(item => {
        if (item && item.trim()) {
          paragraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: "• ",
                  bold: true,
                  color: template.accentColor,
                  size: 22,
                  font: template.bodyFont,
                }),
                new TextRun({
                  text: item.trim(),
                  size: 22,
                  font: template.bodyFont,
                }),
              ],
              spacing: {
                before: 40,
                after: 100,
              },
              indent: {
                firstLine: 0,
                left: 360, // About 0.25 inches
              },
            })
          );
        }
      });
    } else if (sectionKey === 'experience') {
      // First, add the section header
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: getSectionTitle(sectionKey),
              size: 28,
              bold: true,
              font: template.headingFont,
              color: template.headerColor,
            }),
          ],
          spacing: {
            before: 400,
            after: 200,
          },
          heading: HeadingLevel.HEADING_2,
        })
      );
      
      // Handle structured experience entries if available
      if (options.experienceEntries && Array.isArray(options.experienceEntries) && options.experienceEntries.length > 0) {
        // For each experience entry
        options.experienceEntries.forEach((entry: {
          jobTitle: string;
          company: string;
          dateRange: string;
          location?: string;
          responsibilities: string[];
        }) => {
          // Add job title and company
          if (entry.jobTitle || entry.company) {
          paragraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                    text: `${entry.jobTitle || ""}${entry.jobTitle && entry.company ? " at " : ""}${entry.company || ""}`,
                    size: 26,
                    bold: true,
                    font: template.headingFont,
                    color: template.accentColor,
                }),
              ],
              spacing: {
                  before: 200,
                  after: 80,
              },
            })
          );
          }
          
          // Add date range and location if available
          if (entry.dateRange || entry.location) {
          paragraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                    text: `${entry.dateRange || ""}${entry.dateRange && entry.location ? " | " : ""}${entry.location || ""}`,
                    size: 24,
                  italics: true,
                    font: template.bodyFont,
                }),
              ],
              spacing: {
                  before: 0,
                after: 120,
              },
            })
          );
        }
        
          // Add responsibilities as bullet points
          if (entry.responsibilities && Array.isArray(entry.responsibilities)) {
            entry.responsibilities.forEach((responsibility: string) => {
              if (typeof responsibility === 'string' && responsibility.trim()) {
          paragraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                        text: "• ",
                        size: 24,
                        bold: true,
                        font: template.bodyFont,
                        color: template.accentColor,
                      }),
                      new TextRun({
                        text: responsibility.trim(),
                        size: 24,
                        font: template.bodyFont,
                }),
              ],
              spacing: {
                      before: 60,
                      after: 60,
                    },
                    indent: {
                      firstLine: 0,
                      left: 720, // About 0.5 inches
              },
            })
          );
              }
            });
          }
          
          // Add spacing after each entry
          paragraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: "",
                  size: 12,
                }),
              ],
              spacing: {
                after: 120,
              },
            })
          );
        });
        } else {
        // Simple text-based experience section
        const lines = sections[sectionKey].split('\n');
        
        lines.forEach((line: string) => {
          if (line.trim()) {
            if (line.trim().startsWith('•') || line.trim().startsWith('-') || line.trim().startsWith('*')) {
              paragraphs.push(
                new Paragraph({
                  children: [
                    new TextRun({
                      text: "• ",
                      size: 24,
                      bold: true,
                      font: template.bodyFont,
                      color: template.accentColor,
                    }),
                    new TextRun({
                      text: line.trim().replace(/^[•\-*]\s*/, ""),
                      size: 24,
                      font: template.bodyFont,
                    }),
                  ],
                  spacing: {
                    before: 40,
                    after: 40,
                  },
                  indent: {
                    firstLine: 0,
                    left: 720,
                  },
                })
              );
            } else {
              paragraphs.push(
                new Paragraph({
                  children: [
                    new TextRun({
                      text: line.trim(),
                      size: 24,
                      font: template.bodyFont,
                    }),
                  ],
                  spacing: {
                    before: 40,
                    after: 60,
                  },
                })
              );
            }
          }
        });
      }
    } else if (sectionKey === 'skills') {
      // Enhanced skills section
      const skillsText = sections[sectionKey];
      
      // Add industry tag if available
      if (options.industry && options.industry !== 'General') {
        paragraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: "Industry: ",
                italics: true,
                size: 22,
                font: template.bodyFont,
              }),
              new TextRun({
                text: options.industry,
                bold: true,
                size: 22,
                color: template.accentColor,
                font: template.bodyFont,
                    }),
                  ],
                  spacing: {
                    after: 80,
            },
          })
        );
      }
      
      // Process skills content and try to create a simple two-column layout
      // Extract skills from content
      const skillLines = skillsText.split('\n');
      const skills: string[] = [];
      
      skillLines.forEach((line: string) => {
        if (line.trim()) {
          const cleanLine = line.trim().replace(/^[•\-*]\s*/, "");
          if (cleanLine.includes(',')) {
            // Split comma-separated skills
            skills.push(...cleanLine.split(',').map(s => s.trim()).filter(s => s));
          } else {
            skills.push(cleanLine);
          }
        }
      });
      
      // If we were able to extract individual skills, create enhanced layout
      if (skills.length > 0) {
        try {
          // Create a simple bullet list in two columns
          const midpoint = Math.ceil(skills.length / 2);
          const column1 = skills.slice(0, midpoint);
          const column2 = skills.slice(midpoint);
          
          // Create a table for the skills
          const rows: TableRow[] = [];
          
          // Create rows where each row has two skills, one from each column
          for (let i = 0; i < midpoint; i++) {
            const cells: TableCell[] = [];
            
            // Add first cell (from column 1)
            cells.push(
              new TableCell({
                width: { size: 50, type: WidthType.PERCENTAGE },
                children: [
                  new Paragraph({
                    children: [
                      new TextRun({
                        text: "• ",
                        bold: true,
                        color: template.accentColor,
                        size: 22,
                        font: template.bodyFont,
                      }),
                      new TextRun({
                        text: column1[i],
                        size: 22,
                        font: template.bodyFont,
                      }),
                    ],
                  }),
                ],
                borders: {
                  top: { style: BorderStyle.NONE },
                  bottom: { style: BorderStyle.NONE },
                  left: { style: BorderStyle.NONE },
                  right: { style: BorderStyle.NONE },
                },
              })
            );
            
            // Add second cell if there's a skill in column 2 for this row
            if (i < column2.length) {
              cells.push(
                new TableCell({
                  width: { size: 50, type: WidthType.PERCENTAGE },
                  children: [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: "• ",
                          bold: true,
                          color: template.accentColor,
                          size: 22,
                          font: template.bodyFont,
                        }),
                        new TextRun({
                          text: column2[i],
                          size: 22,
                          font: template.bodyFont,
                        }),
                      ],
                    }),
                  ],
                  borders: {
                    top: { style: BorderStyle.NONE },
                    bottom: { style: BorderStyle.NONE },
                    left: { style: BorderStyle.NONE },
                    right: { style: BorderStyle.NONE },
                  },
                })
              );
            } else {
              // Empty cell for balance
              cells.push(
                new TableCell({
                  width: { size: 50, type: WidthType.PERCENTAGE },
                  children: [new Paragraph({})],
                  borders: {
                    top: { style: BorderStyle.NONE },
                    bottom: { style: BorderStyle.NONE },
                    left: { style: BorderStyle.NONE },
                    right: { style: BorderStyle.NONE },
                  },
                })
              );
            }
            
            rows.push(new TableRow({ children: cells }));
          }
          
          // Create and add the table to the document
          const skillsTable = new Table({
            width: { size: 100, type: WidthType.PERCENTAGE },
            rows,
            borders: {
              top: { style: BorderStyle.NONE },
              bottom: { style: BorderStyle.NONE },
              left: { style: BorderStyle.NONE },
              right: { style: BorderStyle.NONE },
              insideHorizontal: { style: BorderStyle.NONE },
              insideVertical: { style: BorderStyle.NONE },
            },
          });
          
          paragraphs.push(new Paragraph({ children: [skillsTable] }));
        } catch (tableError) {
          console.warn("Error creating skills table, falling back to simple list:", tableError);
          // Fallback to simple list if table creation fails
          skills.forEach(skill => {
            paragraphs.push(
              new Paragraph({
                children: [
                  new TextRun({
                    text: "• ",
                    bold: true,
                    color: template.accentColor,
                    size: 22,
                    font: template.bodyFont,
                  }),
                  new TextRun({
                    text: skill,
                    size: 22,
                    font: template.bodyFont,
                  }),
                ],
                spacing: {
                  after: 40,
                },
              })
            );
          });
        }
      } else {
        // Fallback to original lines if we couldn't extract skills
        skillLines.forEach((line: string) => {
          if (line.trim()) {
            paragraphs.push(
              new Paragraph({
                children: [
                  new TextRun({
                    text: line.trim().replace(/^[•\-*]\s*/, "• "),
                    size: 22,
                    font: template.bodyFont,
                  }),
                ],
                spacing: {
                  after: 40,
                },
              })
            );
          }
        });
      }
    } else if (sectionKey === 'profile') {
      // Special formatting for profile section
      const contentText = sections[sectionKey] as string;
      
      // Format as a paragraph
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: contentText.replace(/\n/g, ' '),
              size: 22,
              font: template.bodyFont,
            }),
          ],
          spacing: {
            after: 120,
          },
        })
      );
    } else {
      // Process other sections (education, languages)
      const contentText = sections[sectionKey] as string;
      const contentLines = contentText.split('\n');
      
      contentLines.forEach((line: string) => {
        if (line.trim()) {
          paragraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: line.trim().replace(/^[•\-*]\s*/, "• "),
                  size: 22,
                  font: template.bodyFont,
                }),
              ],
              spacing: {
                after: 40,
              },
            })
          );
        }
      });
    }
    
    // Add extra spacing after section
    paragraphs.push(
      new Paragraph({
              spacing: {
                after: 120,
              },
      })
    );
  }
  
  // Add footer with ATS score if provided
  if (options.atsScore !== undefined || options.improvedAtsScore !== undefined) {
    const scoreText = options.improvedAtsScore !== undefined
      ? `Original ATS Score: ${options.atsScore || 0} | Improved ATS Score: ${options.improvedAtsScore}`
      : `ATS Score: ${options.atsScore || 0}`;
      
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: scoreText,
            size: 18,
            color: "999999",
            font: template.bodyFont,
          }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: {
          before: 240,
        },
        border: {
          top: {
            color: "#DDDDDD",
            space: 1,
            style: BorderStyle.SINGLE,
            size: 4,
          },
        },
      })
    );
    
    // Add improvements if available
    if (options.improvements && options.improvements.length > 0) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: "Key Improvements Made:",
              bold: true,
              size: 18,
              color: "666666",
              font: template.bodyFont,
            }),
          ],
          alignment: AlignmentType.CENTER,
          spacing: {
            before: 120,
            after: 60,
          },
        })
      );
      
      options.improvements.forEach((improvement: string, index: number) => {
        if (improvement && improvement.trim()) {
          paragraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: `${index + 1}. ${improvement.trim()}`,
                  size: 16,
                  color: "666666",
                  font: template.bodyFont,
                }),
              ],
              alignment: AlignmentType.CENTER,
              spacing: {
                after: 20,
              },
            })
          );
        }
      });
    }
    
    // Add a small branding note
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: "Generated by CV Optimizer",
            size: 16,
            color: "BBBBBB",
            font: template.bodyFont,
          }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: {
          before: 120,
        },
      })
    );
  }
  
  return paragraphs;
}

/**
 * Parse the optimized text into structured sections
 */
function parseOptimizedText(text: string): {
  header: string;
  profile: string;
  experience: string;
  achievements: string[];
  goals: string[];
  skills: string;
  languages: string;
  education: string;
} {
  // Default structure
  const sections = {
    header: "",
    profile: "",
    experience: "",
    achievements: [] as string[],
    goals: [] as string[],
    skills: "",
    languages: "",
    education: ""
  };
  
  // Check if the text is already in a structured format with section headers
  if (text.includes("PROFILE") || text.includes("EXPERIENCE") || text.includes("ACHIEVEMENTS") || 
      text.includes("Profile") || text.includes("Experience") || text.includes("Achievements")) {
    
    // Define regex patterns for section identification
    const profilePatterns = [/^(PROFILE|SUMMARY|ABOUT ME|PROFESSIONAL SUMMARY|CAREER OBJECTIVE|Profile|Summary)/i];
    const experiencePatterns = [/^(EXPERIENCE|EMPLOYMENT|WORK HISTORY|PROFESSIONAL EXPERIENCE|Experience|Work History)/i];
    const achievementsPatterns = [/^(ACHIEVEMENTS|ACCOMPLISHMENTS|KEY ACCOMPLISHMENTS|MAJOR ACHIEVEMENTS|Achievements)/i];
    const goalsPatterns = [/^(GOALS|OBJECTIVES|CAREER GOALS|PROFESSIONAL GOALS|ASPIRATIONS|Goals)/i];
    const skillsPatterns = [/^(SKILLS|TECHNICAL SKILLS|COMPETENCIES|CORE COMPETENCIES|KEY SKILLS|EXPERTISE|Skills)/i];
    const languagesPatterns = [/^(LANGUAGES|LANGUAGE PROFICIENCY|LANGUAGE SKILLS|Languages)/i];
    const educationPatterns = [/^(EDUCATION|ACADEMIC BACKGROUND|EDUCATIONAL QUALIFICATIONS|ACADEMIC QUALIFICATIONS|Education)/i];
    
    // Split text into lines
    const lines = text.split('\n').filter(line => line.trim() !== "");
    
    // Extract header (first 2-3 lines typically contain name and contact info)
    if (lines.length > 0) {
      sections.header = lines.slice(0, Math.min(3, lines.length)).join('\n');
    }
    
    // Process remaining lines to identify sections
    let currentSection = "";
    let sectionContent: string[] = [];
    
    for (let i = 3; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Check for section headers using the defined patterns
      const isProfileSection = profilePatterns.some(pattern => pattern.test(line));
      const isExperienceSection = experiencePatterns.some(pattern => pattern.test(line));
      const isAchievementsSection = achievementsPatterns.some(pattern => pattern.test(line));
      const isGoalsSection = goalsPatterns.some(pattern => pattern.test(line));
      const isSkillsSection = skillsPatterns.some(pattern => pattern.test(line));
      const isLanguagesSection = languagesPatterns.some(pattern => pattern.test(line));
      const isEducationSection = educationPatterns.some(pattern => pattern.test(line));
      
      if (isProfileSection) {
        currentSection = "profile";
        sectionContent = [];
        continue;
      } else if (isExperienceSection) {
        currentSection = "experience";
        sectionContent = [];
        continue;
      } else if (isAchievementsSection) {
        currentSection = "achievements";
        sectionContent = [];
        continue;
      } else if (isGoalsSection) {
        currentSection = "goals";
        sectionContent = [];
        continue;
      } else if (isSkillsSection) {
        currentSection = "skills";
        sectionContent = [];
        continue;
      } else if (isLanguagesSection) {
        currentSection = "languages";
        sectionContent = [];
        continue;
      } else if (isEducationSection) {
        currentSection = "education";
        sectionContent = [];
        continue;
      } else if (/^[A-Z\s]{2,}:?$/i.test(line) || /^[A-Z\s]{2,}$/i.test(line)) {
        // This looks like a new section header we don't explicitly handle
        currentSection = "";
        continue;
      }
      
      // Add content to current section
      if (currentSection) {
        if (currentSection === "achievements" || currentSection === "goals") {
          // For achievements and goals, each line is a separate item
          if (line.trim()) {
            // Check if line starts with a bullet point, if not add one
            const cleanLine = line.replace(/^[-•*]\s*/, "").trim();
            if (cleanLine) {
              if (currentSection === "achievements") {
                sections.achievements.push(cleanLine);
              } else {
                sections.goals.push(cleanLine);
              }
            }
          }
        } else {
          // For other sections, accumulate text
          sectionContent.push(line);
          
          if (currentSection === "profile") {
            sections.profile = sectionContent.join('\n');
          } else if (currentSection === "experience") {
            sections.experience = sectionContent.join('\n');
          } else if (currentSection === "skills") {
            sections.skills = sectionContent.join('\n');
          } else if (currentSection === "languages") {
            sections.languages = sectionContent.join('\n');
          } else if (currentSection === "education") {
            sections.education = sectionContent.join('\n');
          }
        }
      } else if (!currentSection && i >= 3) {
        // If we haven't identified a section yet but we're past the header,
        // assume it's part of the profile
        if (!sections.profile) {
          sections.profile = line;
        } else {
          sections.profile += '\n' + line;
        }
      }
    }
  } else {
    // Unstructured text - try to extract basic information
    const lines = text.split('\n').filter(line => line.trim() !== "");
    
    // First few lines are likely the header
    if (lines.length > 0) {
      sections.header = lines.slice(0, Math.min(3, lines.length)).join('\n');
      
      // Look for experience section markers
      const experienceIndex = lines.findIndex((line, index) => 
        index > 2 && /experience|employment|work history/i.test(line)
      );
      
      if (experienceIndex !== -1) {
        // Found experience section
        const skillsIndex = lines.findIndex((line, index) => 
          index > experienceIndex && /skills|competencies|expertise/i.test(line)
        );
        
        const educationIndex = lines.findIndex((line, index) => 
          index > experienceIndex && /education|academic|qualifications/i.test(line)
        );
        
        // Determine the end of the experience section
        const experienceEndIndex = Math.min(
          skillsIndex !== -1 ? skillsIndex : lines.length,
          educationIndex !== -1 ? educationIndex : lines.length
        );
        
        // Extract experience section
        sections.experience = lines.slice(experienceIndex + 1, experienceEndIndex).join('\n');
        
        // Extract profile (between header and experience)
        if (experienceIndex > 3) {
          sections.profile = lines.slice(3, experienceIndex).join('\n');
        }
        
        // Extract skills section if found
        if (skillsIndex !== -1) {
          const skillsEndIndex = educationIndex !== -1 && educationIndex > skillsIndex
            ? educationIndex
            : lines.length;
            
          sections.skills = lines.slice(skillsIndex + 1, skillsEndIndex).join('\n');
        }
        
        // Extract education section if found
        if (educationIndex !== -1) {
          sections.education = lines.slice(educationIndex + 1).join('\n');
        }
      } else {
        // No clear sections - treat everything after header as profile
        sections.profile = lines.slice(3).join('\n');
      }
    }
  }
  
  return sections;
}

/**
 * Get the display title for a section
 */
function getSectionTitle(sectionKey: string): string {
  const titles: Record<string, string> = {
    profile: "PROFILE",
    experience: "EXPERIENCE",
    achievements: "ACHIEVEMENTS",
    goals: "GOALS",
    skills: "SKILLS",
    languages: "LANGUAGES",
    education: "EDUCATION"
  };
  
  return titles[sectionKey] || sectionKey.toUpperCase();
}

/**
 * Get template settings for document styling
 */
function getTemplateSettings(templateName: string) {
  const templates = {
    professional: {
      name: 'professional',
      headerColor: '333333',
      accentColor: 'B4916C', 
      bgColor: 'FFFFFF',
      headingFont: 'Arial',
      bodyFont: 'Arial'
    },
    modern: {
      name: 'modern',
      headerColor: '2D5597',
      accentColor: '4472C4',
      bgColor: 'FFFFFF',
      headingFont: 'Calibri',
      bodyFont: 'Calibri'
    },
    minimal: {
      name: 'minimal',
      headerColor: '000000',
      accentColor: '666666',
      bgColor: 'FFFFFF',
      headingFont: 'Calibri Light',
      bodyFont: 'Calibri'
    },
    creative: {
      name: 'creative',
      headerColor: '7030A0',
      accentColor: 'A5A5A5',
      bgColor: 'FFFFFF',
      headingFont: 'Century Gothic',
      bodyFont: 'Calibri'
    }
  };
  
  // Select template (fallback to professional if invalid)
  const templateKey = templateName as keyof typeof templates;
  return templates[templateKey] || templates.professional;
} 