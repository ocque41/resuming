import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, BorderStyle, TabStopPosition, TabStopType, UnderlineType, ShadingType, WidthType, Table, TableRow, TableCell, ImageRun } from "docx";

interface DocxGenerationOptions {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string[];
  description?: string;
  atsScore?: number;
  improvedAtsScore?: number;
  improvements?: string[];
  experienceEntries?: Array<{
    jobTitle: string;
    company: string;
    dateRange: string;
    location?: string;
    responsibilities: string[];
  }>;
  industry?: string;
}

/**
 * Generates a DOCX file from optimized CV text
 * @param cvText The optimized CV text to convert to DOCX
 * @param options Additional options for the DOCX document
 * @returns A Buffer containing the generated DOCX file
 */
export async function generateDocx(cvText: string, options: DocxGenerationOptions = {}): Promise<Buffer> {
  if (!cvText) {
    throw new Error('CV text is required');
  }

  try {
    // Log what we're processing
    console.log(`Generating DOCX document from ${cvText.length} characters of text`);
    
    // Validate options
    if (options.experienceEntries && !Array.isArray(options.experienceEntries)) {
      console.warn("Invalid experienceEntries format - expected array. Using empty array instead.");
      options.experienceEntries = [];
    }
    
    if (options.improvements && !Array.isArray(options.improvements)) {
      console.warn("Invalid improvements format - expected array. Using empty array instead.");
      options.improvements = [];
    }
    
    // Default options with safe defaults
    const fileName = options.title || "Optimized_CV";
    const authorName = options.author || "CV Optimizer";
    
    // Parse the optimized text to identify sections using a more reliable approach
    const sections = parseOptimizedText(cvText);
    console.log("Parsed sections:", Object.keys(sections));
    
    // Validate that we extracted some sections
    if (!sections || Object.keys(sections).length === 0) {
      console.warn("No sections extracted from CV text - document may be incomplete");
    }
    
    // Create simpler document with basic structure to avoid compatibility issues
    const doc = new Document({
      creator: authorName,
      title: fileName,
      description: "Optimized CV generated by CV Optimizer",
      sections: [{
        properties: {
          page: {
            margin: {
              top: 1000, // top margin in twips (1440 twips = 1 inch)
              right: 1000,
              bottom: 1000,
              left: 1000,
            },
          },
        },
        children: createSimpleDocumentContent(sections, options),
      }],
    });
    
    // Generate the document as a buffer with explicit try/catch
    try {
      const buffer = await Packer.toBuffer(doc);
      
      // Validate the buffer
      if (!buffer || buffer.length === 0) {
        throw new Error("Generated an empty document buffer");
      }
      
      console.log(`Successfully generated DOCX buffer of ${buffer.length} bytes`);
      return buffer;
    } catch (packError) {
      console.error("Error packing document:", packError);
      throw new Error(`Document packing failed: ${packError instanceof Error ? packError.message : String(packError)}`);
    }
  } catch (error) {
    console.error("Error generating DOCX:", error);
    // Re-throw with more context to help debugging
    throw new Error(`Failed to generate DOCX document: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Creates a simpler document content structure that's more compatible with all Word versions
 */
function createSimpleDocumentContent(
  sections: {
    header: string;
    profile: string;
    experience: string;
    achievements: string[];
    goals: string[];
    skills: string;
    languages: string;
    education: string;
  },
  options: DocxGenerationOptions
): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  // Process header
  if (sections.header) {
    const headerLines = sections.header.split('\n').filter(line => line.trim());
    
    if (headerLines.length > 0) {
      // First line is the name
      paragraphs.push(
        new Paragraph({
          text: headerLines[0],
          heading: HeadingLevel.HEADING_1,
          alignment: AlignmentType.CENTER,
          spacing: { after: 120 },
        })
      );
      
      // Contact info
      if (headerLines.length > 1) {
        const contactInfo = headerLines.slice(1).join(' | ');
        paragraphs.push(
          new Paragraph({
            text: contactInfo,
            alignment: AlignmentType.CENTER,
            spacing: { after: 240 },
          })
        );
      }
    }
  }
  
  // Process profile
  if (sections.profile) {
    paragraphs.push(
      new Paragraph({
        text: "PROFILE",
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 240, after: 120 },
      })
    );
    
    paragraphs.push(
      new Paragraph({
        text: sections.profile,
        spacing: { after: 240 },
      })
    );
  }
  
  // Process experience
  if (sections.experience) {
    paragraphs.push(
      new Paragraph({
        text: "EXPERIENCE",
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 240, after: 120 },
      })
    );
    
    // Check if we have structured experience
    if (options.experienceEntries && options.experienceEntries.length > 0) {
      options.experienceEntries.forEach(entry => {
        // Job title and company
        paragraphs.push(
          new Paragraph({
            text: `${entry.jobTitle} | ${entry.company}`,
            spacing: { before: 120, after: 40 },
          })
        );
        
        // Date and location
        paragraphs.push(
          new Paragraph({
            text: `${entry.dateRange}${entry.location ? ` | ${entry.location}` : ''}`,
            spacing: { after: 80 },
          })
        );
        
        // Responsibilities
        if (entry.responsibilities && entry.responsibilities.length > 0) {
          entry.responsibilities.forEach(resp => {
            paragraphs.push(
              new Paragraph({
                text: `• ${resp}`,
                spacing: { after: 40 },
              })
            );
          });
        }
        
        // Add spacing after each entry
        paragraphs.push(
          new Paragraph({
            spacing: { after: 120 },
          })
        );
      });
    } else {
      // Regular text processing
      const lines = sections.experience.split('\n');
      lines.forEach(line => {
        if (line.trim()) {
          paragraphs.push(
            new Paragraph({
              text: line.trim(),
              spacing: { after: 40 },
            })
          );
        }
      });
    }
  }
  
  // Process skills
  if (sections.skills) {
    paragraphs.push(
      new Paragraph({
        text: "SKILLS",
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 240, after: 120 },
      })
    );
    
    // Simple approach for skills
    const skillLines = sections.skills.split('\n');
    skillLines.forEach(line => {
      if (line.trim()) {
        paragraphs.push(
          new Paragraph({
            text: line.trim(),
            spacing: { after: 40 },
          })
        );
      }
    });
  }
  
  // Process education
  if (sections.education) {
    paragraphs.push(
      new Paragraph({
        text: "EDUCATION",
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 240, after: 120 },
      })
    );
    
    const educationLines = sections.education.split('\n');
    educationLines.forEach(line => {
      if (line.trim()) {
        paragraphs.push(
          new Paragraph({
            text: line.trim(),
            spacing: { after: 40 },
          })
        );
      }
    });
  }
  
  // Process languages
  if (sections.languages) {
    paragraphs.push(
      new Paragraph({
        text: "LANGUAGES",
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 240, after: 120 },
      })
    );
    
    const languageLines = sections.languages.split('\n');
    languageLines.forEach(line => {
      if (line.trim()) {
        paragraphs.push(
          new Paragraph({
            text: line.trim(),
            spacing: { after: 40 },
          })
        );
      }
    });
  }
  
  // Process achievements
  if (sections.achievements && sections.achievements.length > 0) {
    paragraphs.push(
      new Paragraph({
        text: "ACHIEVEMENTS",
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 240, after: 120 },
      })
    );
    
    sections.achievements.forEach(achievement => {
      paragraphs.push(
        new Paragraph({
          text: `• ${achievement}`,
          spacing: { after: 40 },
        })
      );
    });
  }
  
  // Process goals
  if (sections.goals && sections.goals.length > 0) {
    paragraphs.push(
      new Paragraph({
        text: "GOALS",
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 240, after: 120 },
      })
    );
    
    sections.goals.forEach(goal => {
      paragraphs.push(
        new Paragraph({
          text: `• ${goal}`,
          spacing: { after: 40 },
        })
      );
    });
  }
  
  // Add footer with ATS score if provided
  if (options.atsScore !== undefined || options.improvedAtsScore !== undefined) {
    paragraphs.push(
      new Paragraph({
        text: "\n", // Empty line before footer
        spacing: { before: 240 },
      })
    );
    
    const scoreText = options.improvedAtsScore !== undefined
      ? `Original ATS Score: ${options.atsScore || 0} | Improved ATS Score: ${options.improvedAtsScore}`
      : `ATS Score: ${options.atsScore || 0}`;
      
    paragraphs.push(
      new Paragraph({
        text: scoreText,
        alignment: AlignmentType.CENTER,
        spacing: { before: 120 },
      })
    );
    
    paragraphs.push(
      new Paragraph({
        text: "Generated by CV Optimizer",
        alignment: AlignmentType.CENTER,
        spacing: { before: 60 },
      })
    );
  }
  
  return paragraphs;
}

/**
 * Parse the optimized text into structured sections
 */
function parseOptimizedText(text: string): {
  header: string;
  profile: string;
  experience: string;
  achievements: string[];
  goals: string[];
  skills: string;
  languages: string;
  education: string;
} {
  // Default structure
  const sections = {
    header: "",
    profile: "",
    experience: "",
    achievements: [] as string[],
    goals: [] as string[],
    skills: "",
    languages: "",
    education: ""
  };
  
  // Check if the text is already in a structured format with section headers
  if (text.includes("PROFILE") || text.includes("EXPERIENCE") || text.includes("ACHIEVEMENTS") || 
      text.includes("Profile") || text.includes("Experience") || text.includes("Achievements")) {
    
    // Define regex patterns for section identification
    const profilePatterns = [/^(PROFILE|SUMMARY|ABOUT ME|PROFESSIONAL SUMMARY|CAREER OBJECTIVE|Profile|Summary)/i];
    const experiencePatterns = [/^(EXPERIENCE|EMPLOYMENT|WORK HISTORY|PROFESSIONAL EXPERIENCE|Experience|Work History)/i];
    const achievementsPatterns = [/^(ACHIEVEMENTS|ACCOMPLISHMENTS|KEY ACCOMPLISHMENTS|MAJOR ACHIEVEMENTS|Achievements)/i];
    const goalsPatterns = [/^(GOALS|OBJECTIVES|CAREER GOALS|PROFESSIONAL GOALS|ASPIRATIONS|Goals)/i];
    const skillsPatterns = [/^(SKILLS|TECHNICAL SKILLS|COMPETENCIES|CORE COMPETENCIES|KEY SKILLS|EXPERTISE|Skills)/i];
    const languagesPatterns = [/^(LANGUAGES|LANGUAGE PROFICIENCY|LANGUAGE SKILLS|Languages)/i];
    const educationPatterns = [/^(EDUCATION|ACADEMIC BACKGROUND|EDUCATIONAL QUALIFICATIONS|ACADEMIC QUALIFICATIONS|Education)/i];
    
    // Split text into lines
    const lines = text.split('\n').filter(line => line.trim() !== "");
    
    // Extract header (first 2-3 lines typically contain name and contact info)
    if (lines.length > 0) {
      sections.header = lines.slice(0, Math.min(3, lines.length)).join('\n');
    }
    
    // Process remaining lines to identify sections
    let currentSection = "";
    let sectionContent: string[] = [];
    
    for (let i = 3; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Check for section headers using the defined patterns
      const isProfileSection = profilePatterns.some(pattern => pattern.test(line));
      const isExperienceSection = experiencePatterns.some(pattern => pattern.test(line));
      const isAchievementsSection = achievementsPatterns.some(pattern => pattern.test(line));
      const isGoalsSection = goalsPatterns.some(pattern => pattern.test(line));
      const isSkillsSection = skillsPatterns.some(pattern => pattern.test(line));
      const isLanguagesSection = languagesPatterns.some(pattern => pattern.test(line));
      const isEducationSection = educationPatterns.some(pattern => pattern.test(line));
      
      if (isProfileSection) {
        currentSection = "profile";
        sectionContent = [];
        continue;
      } else if (isExperienceSection) {
        currentSection = "experience";
        sectionContent = [];
        continue;
      } else if (isAchievementsSection) {
        currentSection = "achievements";
        sectionContent = [];
        continue;
      } else if (isGoalsSection) {
        currentSection = "goals";
        sectionContent = [];
        continue;
      } else if (isSkillsSection) {
        currentSection = "skills";
        sectionContent = [];
        continue;
      } else if (isLanguagesSection) {
        currentSection = "languages";
        sectionContent = [];
        continue;
      } else if (isEducationSection) {
        currentSection = "education";
        sectionContent = [];
        continue;
      } else if (/^[A-Z\s]{2,}:?$/i.test(line) || /^[A-Z\s]{2,}$/i.test(line)) {
        // This looks like a new section header we don't explicitly handle
        currentSection = "";
        continue;
      }
      
      // Add content to current section
      if (currentSection) {
        if (currentSection === "achievements" || currentSection === "goals") {
          // For achievements and goals, each line is a separate item
          if (line.trim()) {
            // Check if line starts with a bullet point, if not add one
            const cleanLine = line.replace(/^[-•*]\s*/, "").trim();
            if (cleanLine) {
              if (currentSection === "achievements") {
                sections.achievements.push(cleanLine);
              } else {
                sections.goals.push(cleanLine);
              }
            }
          }
        } else {
          // For other sections, accumulate text
          sectionContent.push(line);
          
          if (currentSection === "profile") {
            sections.profile = sectionContent.join('\n');
          } else if (currentSection === "experience") {
            sections.experience = sectionContent.join('\n');
          } else if (currentSection === "skills") {
            sections.skills = sectionContent.join('\n');
          } else if (currentSection === "languages") {
            sections.languages = sectionContent.join('\n');
          } else if (currentSection === "education") {
            sections.education = sectionContent.join('\n');
          }
        }
      } else if (!currentSection && i >= 3) {
        // If we haven't identified a section yet but we're past the header,
        // assume it's part of the profile
        if (!sections.profile) {
          sections.profile = line;
        } else {
          sections.profile += '\n' + line;
        }
      }
    }
  } else {
    // Unstructured text - try to extract basic information
    const lines = text.split('\n').filter(line => line.trim() !== "");
    
    // First few lines are likely the header
    if (lines.length > 0) {
      sections.header = lines.slice(0, Math.min(3, lines.length)).join('\n');
      
      // Look for experience section markers
      const experienceIndex = lines.findIndex((line, index) => 
        index > 2 && /experience|employment|work history/i.test(line)
      );
      
      if (experienceIndex !== -1) {
        // Found experience section
        const skillsIndex = lines.findIndex((line, index) => 
          index > experienceIndex && /skills|competencies|expertise/i.test(line)
        );
        
        const educationIndex = lines.findIndex((line, index) => 
          index > experienceIndex && /education|academic|qualifications/i.test(line)
        );
        
        // Determine the end of the experience section
        const experienceEndIndex = Math.min(
          skillsIndex !== -1 ? skillsIndex : lines.length,
          educationIndex !== -1 ? educationIndex : lines.length
        );
        
        // Extract experience section
        sections.experience = lines.slice(experienceIndex + 1, experienceEndIndex).join('\n');
        
        // Extract profile (between header and experience)
        if (experienceIndex > 3) {
          sections.profile = lines.slice(3, experienceIndex).join('\n');
        }
        
        // Extract skills section if found
        if (skillsIndex !== -1) {
          const skillsEndIndex = educationIndex !== -1 && educationIndex > skillsIndex
            ? educationIndex
            : lines.length;
            
          sections.skills = lines.slice(skillsIndex + 1, skillsEndIndex).join('\n');
        }
        
        // Extract education section if found
        if (educationIndex !== -1) {
          sections.education = lines.slice(educationIndex + 1).join('\n');
        }
      } else {
        // No clear sections - treat everything after header as profile
        sections.profile = lines.slice(3).join('\n');
      }
    }
  }
  
  return sections;
}

/**
 * Get the display title for a section
 */
function getSectionTitle(sectionKey: string): string {
  const titles: Record<string, string> = {
    profile: "PROFILE",
    experience: "EXPERIENCE",
    achievements: "ACHIEVEMENTS",
    goals: "GOALS",
    skills: "SKILLS",
    languages: "LANGUAGES",
    education: "EDUCATION"
  };
  
  return titles[sectionKey] || sectionKey.toUpperCase();
} 