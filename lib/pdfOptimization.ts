// lib/pdfOptimization.ts
import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';

/**
 * Overlays the optimized CV text onto the original PDF.
 *
 * @param originalPdfBytes - The original PDF as a Uint8Array.
 * @param optimizedText - The optimized CV text generated by GPT-3.5-turbo.
 * @returns A Promise that resolves with the modified PDF as a Base64-encoded string.
 */
export async function modifyPDFWithOptimizedContent(
  originalPdfBytes: Uint8Array,
  optimizedText: string
): Promise<string> {
  // Load the original PDF document.
  const pdfDoc = await PDFDocument.load(originalPdfBytes);

  // Choose a page to modify.
  // For this example, if the original PDF has more than one page, we modify page 2.
  // Otherwise, we modify page 1.
  let pageToModify = pdfDoc.getPageCount() >= 2 ? pdfDoc.getPage(1) : pdfDoc.getPage(0);

  // Alternatively, if you prefer to create a new page for the optimized version:
  // const { width, height } = pdfDoc.getPage(0).getSize();
  // const pageToModify = pdfDoc.addPage([width, height]);

  // Embed a standard font.
  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);

  // Define text formatting and positioning.
  const { width, height } = pageToModify.getSize();
  const margin = 50;
  const fontSize = 10;
  const lineHeight = fontSize * 1.2;

  // We want to overlay the optimized text in a defined region.
  // For simplicity, we assume the region starts at (margin, height - margin) and has a width of (width - 2*margin).
  // A more robust implementation would use text extraction heuristics to determine where to replace text.
  let startY = height - margin;

  // Split the optimized text into lines.
  // You can implement more advanced word-wrapping logic if necessary.
  const lines = optimizedText.split("\n");

  // Clear or cover the original text area if needed.
  // Here, we simply overlay the new text.
  for (let i = 0; i < lines.length; i++) {
    const textLine = lines[i];
    // If text exceeds the designated region, optionally add a new page.
    if (startY - lineHeight * i < margin) {
      // Add a new page and reset coordinates.
      const newPage = pdfDoc.addPage([width, height]);
      pageToModify = newPage;
      startY = height - margin;
      i = 0; // Reset the loop for new page drawing.
    }
    pageToModify.drawText(textLine, {
      x: margin,
      y: startY - lineHeight * i,
      size: fontSize,
      font: helveticaFont,
      color: rgb(0, 0, 0),
      maxWidth: width - margin * 2,
    });
  }

  // Serialize the modified PDF document.
  const modifiedPdfBytes = await pdfDoc.save();

  // Convert the bytes to a Base64-encoded string (for immediate frontend display or download).
  const base64String = Buffer.from(modifiedPdfBytes).toString("base64");
  return base64String;
}
