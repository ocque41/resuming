import { PDFDocument, StandardFonts, rgb, PDFFont } from "pdf-lib";
import { getOverlayCoordinates } from "./templateMatching";

/**
 * Parses structured optimized text into sections
 */
function parseOptimizedText(optimizedText: string): Record<string, string> {
  const sections: Record<string, string> = {};
  
  // Split by section headers (assuming they're marked with ## or similar)
  const sectionRegex = /##\s*([^#\n]+)\s*\n([\s\S]*?)(?=##\s*[^#\n]+\s*\n|$)/g;
  let match;
  
  while ((match = sectionRegex.exec(optimizedText)) !== null) {
    const sectionName = match[1].trim();
    const sectionContent = match[2].trim();
    sections[sectionName] = sectionContent;
  }
  
  // If no sections found, treat the whole text as one section
  if (Object.keys(sections).length === 0) {
    sections["Content"] = optimizedText;
  }
  
  return sections;
}

/**
 * Wraps the given text into lines that do not exceed maxWidth.
 *
 * @param text - The text to wrap.
 * @param font - The PDF font used.
 * @param fontSize - The font size.
 * @param maxWidth - The maximum width in points.
 * @returns An array of lines.
 */
function wrapText(
  text: string,
  font: PDFFont,
  fontSize: number,
  maxWidth: number
): string[] {
  const words = text.split(" ");
  const lines: string[] = [];
  let currentLine = "";

  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const testLineWidth = font.widthOfTextAtSize(testLine, fontSize);
    if (testLineWidth > maxWidth && currentLine !== "") {
      lines.push(currentLine);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }
  if (currentLine) {
    lines.push(currentLine);
  }
  return lines;
}

/**
 * Overlays the optimized CV text onto the original PDF.
 *
 * @param originalPdfBytes - The original PDF as a Uint8Array.
 * @param optimizedText - The optimized CV text generated by GPT-3.5-turbo.
 * @returns A Promise that resolves with the modified PDF as a Base64-encoded string.
 */
export async function modifyPDFWithOptimizedContent(
  originalPdfBytes: Uint8Array,
  optimizedText: string
): Promise<string> {
  // Load the original PDF document
  const pdfDoc = await PDFDocument.load(originalPdfBytes);
  
  // Parse the optimized text into sections
  const sections = parseOptimizedText(optimizedText);
  
  // Get coordinates for known sections if possible
  const coordinates = await getOverlayCoordinates(originalPdfBytes);
  
  // Get the first page
  const page = pdfDoc.getPage(0);
  const { width, height } = page.getSize();
  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  
  // Default margins and styling
  const margin = 50;
  const fontSize = 10;
  const headerFontSize = 12;
  const lineHeight = fontSize * 1.2;
  const maxWidth = width - margin * 2;
  
  // Starting position - either from coordinates or default
  let currentY = coordinates?.experienceY || height - margin;
  
  // Process each section
  for (const [sectionName, sectionContent] of Object.entries(sections)) {
    // Find section-specific coordinates if available
    const sectionY = getSectionCoordinates(sectionName, coordinates);
    if (sectionY) {
      currentY = sectionY;
    }
    
    // Draw section header
    page.drawText(sectionName, {
      x: margin,
      y: currentY,
      size: headerFontSize,
      font: helveticaBold,
      color: rgb(0, 0, 0),
    });
    
    currentY -= lineHeight * 1.5;
    
    // Process section content with proper paragraph breaks
    const paragraphs = sectionContent.split('\n\n');
    for (const paragraph of paragraphs) {
      const lines = wrapText(paragraph, helveticaFont, fontSize, maxWidth);
      
      for (const line of lines) {
        page.drawText(line, {
          x: margin,
          y: currentY,
          size: fontSize,
          font: helveticaFont,
          color: rgb(0, 0, 0),
        });
        currentY -= lineHeight;
      }
      
      // Add space between paragraphs
      currentY -= lineHeight * 0.5;
    }
    
    // Add space between sections
    currentY -= lineHeight;
  }
  
  // Serialize the modified PDF
  const modifiedPdfBytes = await pdfDoc.save();
  return Buffer.from(modifiedPdfBytes).toString("base64");
}

// Helper function to get section-specific coordinates
function getSectionCoordinates(sectionName: string, coordinates: any): number | null {
  if (!coordinates) return null;
  
  const sectionMap: Record<string, number | undefined> = {
    "Experience": coordinates.experienceY,
    "Education": coordinates.educationY,
    "Skills": coordinates.skillsY,
    // Add more mappings as needed
  };
  
  return sectionMap[sectionName] || null;
}
