// lib/pdfOptimization.ts
import { PDFDocument, StandardFonts, rgb, PDFFont } from "pdf-lib";
import { getOverlayCoordinates } from "./templateMatching";

/**
 * Wraps the given text into lines that do not exceed maxWidth.
 *
 * @param text - The text to wrap.
 * @param font - The PDF font used.
 * @param fontSize - The font size.
 * @param maxWidth - The maximum width in points.
 * @returns An array of lines.
 */
function wrapText(
  text: string,
  font: PDFFont,
  fontSize: number,
  maxWidth: number
): string[] {
  const words = text.split(" ");
  const lines: string[] = [];
  let currentLine = "";

  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const testLineWidth = font.widthOfTextAtSize(testLine, fontSize);
    if (testLineWidth > maxWidth && currentLine !== "") {
      lines.push(currentLine);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }
  if (currentLine) {
    lines.push(currentLine);
  }
  return lines;
}

/**
 * Overlays the optimized CV text onto the original PDF.
 *
 * @param originalPdfBytes - The original PDF as a Uint8Array.
 * @param optimizedText - The optimized CV text generated by GPT-3.5-turbo.
 * @returns A Promise that resolves with the modified PDF as a Base64-encoded string.
 */
export async function modifyPDFWithOptimizedContent(
  originalPdfBytes: Uint8Array,
  optimizedText: string
): Promise<string> {
  // Load the original PDF document.
  const pdfDoc = await PDFDocument.load(originalPdfBytes);

  // Use template matching to see if we can target a known region (e.g., "Experience" section).
  const coordinates = await getOverlayCoordinates(originalPdfBytes);

  let pageToModify;
  if (coordinates) {
    // If coordinates are found, use the first page.
    pageToModify = pdfDoc.getPage(0);
  } else {
    // Fallback: create a new page for the optimized content.
    const { width, height } = pdfDoc.getPage(0).getSize();
    pageToModify = pdfDoc.addPage([width, height]);
  }

  // Embed a standard font.
  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const { width, height } = pageToModify.getSize();
  const margin = 50;
  const fontSize = 12;
  const lineHeight = fontSize * 1.2;
  const maxWidth = width - margin * 2;

  // Determine the starting Y coordinate.
  let startY = coordinates ? coordinates.experienceY : height - margin;

  // If a target region was identified, clear that area by drawing a white rectangle.
  if (coordinates) {
    // Adjust the rectangle dimensions as needed.
    pageToModify.drawRectangle({
      x: margin,
      y: startY - 200, // clear an area 200 points high
      width: maxWidth,
      height: 200,
      color: rgb(1, 1, 1),
    });
  }

  // Wrap the optimized text into lines.
  const lines = wrapText(optimizedText, helveticaFont, fontSize, maxWidth);

  let currentPage = pageToModify;
  let currentY = startY;

  // Draw each line; if text exceeds the available space, add a new page.
  for (const line of lines) {
    if (currentY - lineHeight < margin) {
      // Add a new page and reset Y coordinate.
      currentPage = pdfDoc.addPage([width, height]);
      currentY = height - margin;
    }
    currentPage.drawText(line, {
      x: margin,
      y: currentY,
      size: fontSize,
      font: helveticaFont,
      color: rgb(0, 0, 0),
      maxWidth,
    });
    currentY -= lineHeight;
  }

  // Serialize the modified PDF.
  const modifiedPdfBytes = await pdfDoc.save();
  // Convert the bytes to a Base64-encoded string.
  const base64String = Buffer.from(modifiedPdfBytes).toString("base64");
  return base64String;
}
